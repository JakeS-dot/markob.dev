{
  "version": 3,
  "sources": ["../../bitrain-matrixx/src/bit-rain-column.ts", "../../bitrain-matrixx/src/charamask-engine.ts", "../../bitrain-matrixx/src/matrixx-canvas.ts", "../../bitrain-matrixx/src/index.ts", "../../bitrain-matrixx/src/auto.ts"],
  "sourcesContent": ["/**\r\n * defineBitRainColumn(tag) function that constructs:\r\n * <bit-rain-column> Web Component\r\n *\r\n * Attributes:\r\n *  - left:         string   (e.g. \"20vw\")\r\n *  - duration:     number   (animation duration in seconds)\r\n *  - delay:        number   (animation delay in seconds)\r\n *  - font-size:    number   (font size in px)\r\n *  - blur:         number   (blur level in px)\r\n *  - direction:    \"up\" | \"down\"   (default: \"up\")\r\n *  - bits-color:   string   (CSS color for the bits, default: \"#00ff00\")\r\n *  - rain-display: \"riverflow\" | \"waterfall\"  (default: \"riverflow\")\r\n *\r\n *  • \"riverflow\"  ⇒ bits simply translate (no fade), then immediately reset.\r\n *  • \"waterfall\"  ⇒ bits translate and fade out at the very end of each cycle.\r\n *  • \"bitmask\"  ⇒ bits translate and fade out at the very end of each cycle.\r\n */\r\n\r\nimport { BitRainMode } from \"./matrixx-canvas\";\r\n\r\nexport function defineBitRainColumn(tag = 'bit-rain-column') {\r\n  // SSR guard: skip entirely on the server\r\n  if (typeof globalThis === 'undefined') return;\r\n  if (typeof (globalThis as any).HTMLElement === 'undefined') return;\r\n  if (typeof (globalThis as any).customElements === 'undefined') return;\r\n\r\n  if (customElements.get(tag)) return;\r\n  \r\n  class BitRainColumn extends HTMLElement {\r\n    private bits: string[] = [];\r\n    private intervalId?: number;\r\n    private shadow: ShadowRoot;\r\n\r\n    constructor() {\r\n      super();\r\n      this.shadow = this.attachShadow({ mode: 'open' });\r\n    }\r\n\r\n    connectedCallback() {\r\n      // ─── 1. Read attributes & apply defaults ─────────────────────────────\r\n      const durationAttr = this.getAttribute('duration') ?? '10';\r\n      const delayAttr = this.getAttribute('delay') ?? '0';\r\n      const fontSizeAttr = this.getAttribute('font-size') ?? '14';\r\n      const blurAttr = this.getAttribute('blur') ?? '0';\r\n      const left = this.getAttribute('left') ?? '0px';\r\n      const dirAttr = this.getAttribute('direction') ?? 'up';\r\n      const bitsColor = this.getAttribute('bits-color') ?? '#00ff00';\r\n      const rainDisplay = this.getAttribute('rain-display') ?? 'riverflow' as BitRainMode;\r\n\r\n      const duration = Number(durationAttr);\r\n      const delay = Number(delayAttr);\r\n      const fontSize = Number(fontSizeAttr);\r\n      const blur = Number(blurAttr);\r\n      const direction = (dirAttr === 'down') ? 'down' : 'up';\r\n      const displayMode = rainDisplay as BitRainMode;\r\n\r\n      // ─── 2. Generate random bits (array of \"0\"/\"1\") ─────────────────────────\r\n      const len = Math.floor(Math.random() * 20) + 10;\r\n      this.bits = Array.from({ length: len }, () => (Math.random() < 0.5 ? '0' : '1'));\r\n\r\n      // ─── 3. Build the initial <style> + <span class=\"bit\">…</span> layout ──\r\n      this.shadow.innerHTML = `\r\n      <style>\r\n        :host {\r\n          position: absolute;\r\n          ${direction === 'down' ? 'top: 0;' : 'bottom: 0;'}\r\n          left: ${left};\r\n          font-size: ${fontSize}px;\r\n          filter: blur(${blur}px);\r\n          font-family: monospace;\r\n          line-height: 1.1;\r\n          color: ${bitsColor};\r\n          display: flex;\r\n          flex-direction: column;\r\n          /* animation will be injected after layout in RAF */\r\n        }\r\n\r\n        /* ─── 4 built-in keyframes ───────────────────────────────────────────*/\r\n        @keyframes move-up {\r\n          0%   { transform: translateY(100%);  opacity: 1; }\r\n          100% { transform: translateY(-calc(100vh + 100%)); opacity: 1; }\r\n        }\r\n        @keyframes move-down {\r\n          0%   { transform: translateY(-100%); opacity: 1; }\r\n          100% { transform: translateY(calc(100vh + 100%));  opacity: 1; }\r\n        }\r\n        @keyframes waterfall-up {\r\n          0%   { transform: translateY(100%);  opacity: 1; }\r\n          80%  { opacity: 1; }\r\n          100% { transform: translateY(-100%); opacity: 0; }\r\n        }\r\n        @keyframes waterfall-down {\r\n          0%   { transform: translateY(-100%); opacity: 1; }\r\n          80%  { opacity: 1; }\r\n          100% { transform: translateY(100%);  opacity: 0; }\r\n        }\r\n      </style>\r\n\r\n      ${this.bits.map(bit => `<span class=\"bit\">${bit}</span>`).join('')}\r\n    `;\r\n\r\n      // ─── 5. After first paint, actually set the animation on :host ────────\r\n      // Using requestAnimationFrame ensures the browser has computed the height of the spans.\r\n      requestAnimationFrame(() => {\r\n        // Choose which keyframe to use based on (direction, displayMode)\r\n        let keyframeName: string;\r\n        if (displayMode === 'waterfall') {\r\n          keyframeName = (direction === 'down') ? 'waterfall-down' : 'waterfall-up';\r\n        } else {\r\n          // “riverflow”\r\n          keyframeName = (direction === 'down') ? 'move-down' : 'move-up';\r\n        }\r\n\r\n        // Append to the existing style block so we don't overwrite the keyframes themselves.\r\n        const styleElem = this.shadow.querySelector('style')!;\r\n        styleElem.textContent += `\r\n        :host {\r\n          animation: ${keyframeName} ${duration}s linear infinite;\r\n          animation-delay: -${delay}s;\r\n        }\r\n      `;\r\n\r\n        // Start randomizing the bits once per 200ms\r\n        this.startUpdatingBits();\r\n      });\r\n    }\r\n\r\n    disconnectedCallback() {\r\n      clearInterval(this.intervalId);\r\n    }\r\n\r\n    private startUpdatingBits() {\r\n      this.intervalId = window.setInterval(() => {\r\n        const idx = Math.floor(Math.random() * this.bits.length);\r\n        this.bits[idx] = (Math.random() < 0.5 ? '0' : '1');\r\n\r\n        const spanList = this.shadow.querySelectorAll<HTMLSpanElement>('.bit');\r\n        if (spanList[idx]) {\r\n          spanList[idx].textContent = this.bits[idx];\r\n        }\r\n      }, 200);\r\n    }\r\n  }\r\n  customElements.define(tag, BitRainColumn);\r\n}\r\n", "/**\r\n * CharamaskEngine — Canvas grid “bit rain” (for <matrixx-canvas rain-display=\"charamask\">)\r\n *\r\n * Options (mapped from <matrixx-canvas> attributes):\r\n *  - density:     FLOAT   (0 ~ 10; controls how often columns activate; default: 4)\r\n *  - direction:   \"up\" | \"down\" (default: \"up\")\r\n *  - color:       string  (CSS color for chars; default: \"#00ff00\")\r\n *  - cellSize:    number  (grid cell size in px; default: 18)\r\n *  - speed:       number  (cells per second for the moving head; default: 22)\r\n *  - tailMin:     number  (minimum tail length in cells; default: 6)\r\n *  - tailMax:     number  (maximum tail length in cells; default: 18)\r\n *\r\n * Behavior\r\n *  - Creates a grid over the canvas based on `cellSize` (HiDPI-aware).\r\n *  - Each cell holds a random [A–Z, a–z, 0–9] character with initial opacity 0.\r\n *  - Per column, a “head” moves in `direction` with a random-length tail.\r\n *  - Tail lights cells along its path using a gradient (high → low opacity).\r\n *  - After a tail passes and a cell’s opacity decays back to 0, the cell is\r\n *    re-assigned a new random character.\r\n *  - Column activation frequency scales with `density`. Columns recycle when\r\n *    their tail exits the viewport.\r\n *\r\n * Public API\r\n *  - constructor(canvas: HTMLCanvasElement, options: CharamaskOptions)\r\n *  - attach(canvas: HTMLCanvasElement): void\r\n *  - setOptions(next: CharamaskOptions): void          // hot-update; resizes grid if cellSize changed\r\n *  - start(): void                                     // begins rAF loop; installs resize listener\r\n *  - pause(): void                                     // pauses stepping/drawing (e.g., on hidden tab)\r\n *  - resume(): void\r\n *  - stop(): void                                      // cancels rAF; removes listeners\r\n *\r\n */\r\n\r\n\r\ntype Dir = 'up' | 'down';\r\nexport type CharamaskOptions = {\r\n    direction: Dir;          // up/down\r\n    color: string;           // RGBA/hex\r\n    density: number;         // 0..10 → OVERDRIVE when limit breaks\r\n    cellSize: number;        // px\r\n    speed: number;           // cells / second\r\n    tailMin: number;         // cells\r\n    tailMax: number;         // cells\r\n};\r\n\r\nexport class CharamaskEngine {\r\n    private canvas: HTMLCanvasElement;\r\n    private ctx!: CanvasRenderingContext2D;\r\n    private opts: CharamaskOptions;\r\n    private raf: number | null = null;\r\n    private paused = false;\r\n    private dpr = 1;\r\n\r\n    // grid state\r\n    private cols = 0;\r\n    private rows = 0;\r\n    private chars!: string[];        // length = cols*rows\r\n    private alpha!: Float32Array;    // per-cell current alpha (0..1)\r\n    private active!: boolean[];      // is cell “owned” by a passing tail this frame\r\n\r\n    // streaks: one head per active column (can respawn)\r\n    private heads: number[] = [];    // row index (float), per column\r\n    private tails: number[] = [];    // tail length (cells), per column\r\n    private activeCols: boolean[] = [];\r\n\r\n    private last = 0;\r\n\r\n    constructor(canvas: HTMLCanvasElement, options: CharamaskOptions) {\r\n        this.canvas = canvas;\r\n        this.opts = options;\r\n        this.attach(canvas);\r\n    }\r\n\r\n    private onWindowResize = () => this.resize(false);\r\n\r\n    attach(canvas: HTMLCanvasElement) {\r\n        this.canvas = canvas;\r\n        const ctx = this.canvas.getContext('2d');\r\n        if (!ctx) throw new Error('2d context not available');\r\n        this.ctx = ctx;\r\n        this.resize(true);\r\n    }\r\n\r\n    setOptions(next: CharamaskOptions) {\r\n        // hot-apply where possible\r\n        const cellChanged = next.cellSize !== this.opts.cellSize;\r\n        const dirChanged = next.direction !== this.opts.direction;\r\n        this.opts = { ...this.opts, ...next };\r\n        if (cellChanged) this.resize(true);\r\n        if (dirChanged) this.seedStreaks(); // reset heads to match flow\r\n    }\r\n\r\n    start() {\r\n        if (this.raf !== null) return;\r\n        this.last = performance.now();\r\n        const tick = (t: number) => {\r\n            if (this.paused) { this.last = t; this.raf = requestAnimationFrame(tick); return; }\r\n            const dt = Math.min(80, t - this.last) / 1000; // clamp\r\n            this.step(dt);\r\n            this.draw();\r\n            this.last = t;\r\n            this.raf = requestAnimationFrame(tick);\r\n        };\r\n        this.raf = requestAnimationFrame(tick);\r\n\r\n        // auto-resize\r\n        addEventListener('resize', this.onWindowResize);\r\n    }\r\n\r\n    pause() { this.paused = true; }\r\n    resume() { this.paused = false; }\r\n    stop() { if (this.raf !== null) cancelAnimationFrame(this.raf); this.raf = null; removeEventListener('resize', this.onWindowResize); }\r\n\r\n    // ---------- internals ----------\r\n    private resize = (hard = false) => {\r\n        const cssW = this.canvas.clientWidth || this.canvas.getBoundingClientRect().width || innerWidth;\r\n        const cssH = this.canvas.clientHeight || this.canvas.getBoundingClientRect().height || innerHeight;\r\n        const dpr = Math.max(1, Math.floor(devicePixelRatio || 1));\r\n        if (!hard && this.canvas.width === Math.floor(cssW * dpr) && this.canvas.height === Math.floor(cssH * dpr) && this.dpr === dpr) return;\r\n\r\n        this.dpr = dpr;\r\n        this.canvas.width = Math.max(1, Math.floor(cssW * dpr));\r\n        this.canvas.height = Math.max(1, Math.floor(cssH * dpr));\r\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        this.ctx.scale(dpr, dpr);\r\n\r\n        // grid geometry\r\n        const s = Math.max(8, this.opts.cellSize);\r\n        this.cols = Math.max(1, Math.floor(cssW / s));\r\n        this.rows = Math.max(1, Math.floor(cssH / s));\r\n\r\n        // allocate\r\n        this.chars = new Array(this.cols * this.rows);\r\n        this.alpha = new Float32Array(this.cols * this.rows);\r\n        this.active = new Array(this.cols * this.rows).fill(false);\r\n\r\n        // init chars + streaks\r\n        for (let i = 0; i < this.chars.length; i++) this.chars[i] = randChar();\r\n        this.seedStreaks();\r\n    };\r\n\r\n    private seedStreaks() {\r\n        this.heads = new Array(this.cols).fill(0);\r\n        this.tails = new Array(this.cols).fill(0);\r\n        this.activeCols = new Array(this.cols).fill(false);\r\n\r\n        const goingDown = this.opts.direction === 'down';\r\n        for (let c = 0; c < this.cols; c++) {\r\n            this.heads[c] = goingDown ? -rand(0, this.rows) : this.rows + rand(0, this.rows);\r\n            this.tails[c] = Math.floor(rand(this.opts.tailMin, this.opts.tailMax + 1));\r\n            this.activeCols[c] = Math.random() < this.activationProb(); // initial chance\r\n        }\r\n    }\r\n\r\n    private activationProb() {\r\n        // map density 0..10 to probability per column per “cycle”\r\n        // gentle curve: p = 0.06 + 0.08 * (density/10)^0.9\r\n        const d = Math.max(0, Math.min(10, this.opts.density));\r\n        return 0.06 + 0.08 * Math.pow(d / 10, 0.9);\r\n    }\r\n\r\n    private step(dt: number) {\r\n        const { speed, direction } = this.opts;\r\n        const cellsPerSec = Math.max(1, speed);\r\n        const deltaCells = cellsPerSec * dt;\r\n\r\n        // decay alphas\r\n        for (let i = 0; i < this.alpha.length; i++) {\r\n            if (!this.active[i] && this.alpha[i] > 0) {\r\n                this.alpha[i] = Math.max(0, this.alpha[i] - 1.2 * dt); // decay rate\r\n                if (this.alpha[i] === 0) this.chars[i] = randChar();   // reassign when fully off\r\n            }\r\n            this.active[i] = false; // reset mark; will be set below if lit this frame\r\n        }\r\n\r\n        // advance heads and light tails\r\n        const goingDown = direction === 'down';\r\n        for (let c = 0; c < this.cols; c++) {\r\n            if (!this.activeCols[c]) {\r\n                // chance to (re)activate this column\r\n                if (Math.random() < this.activationProb() * dt) {\r\n                    this.activeCols[c] = true;\r\n                    this.tails[c] = Math.floor(rand(this.opts.tailMin, this.opts.tailMax + 1));\r\n                    this.heads[c] = goingDown ? -1 : this.rows + 1;\r\n                } else continue;\r\n            }\r\n\r\n            // move head\r\n            this.heads[c] += goingDown ? deltaCells : -deltaCells;\r\n\r\n            // compute integer head position\r\n            const headRow = Math.floor(this.heads[c]);\r\n            const len = this.tails[c];\r\n\r\n            // light tail cells\r\n            for (let k = 0; k < len; k++) {\r\n                const r = goingDown ? (headRow - k) : (headRow + k);\r\n                if (r < 0 || r >= this.rows) continue;\r\n                const idx = r * this.cols + c;\r\n                const t = k / len;               // tail progress (0 at head → 1 at end)\r\n                const a = 1 - t * t;             // ease-out for nicer gradient\r\n                this.alpha[idx] = Math.max(this.alpha[idx], a);\r\n                this.active[idx] = true;\r\n            }\r\n\r\n            // recycle when fully offscreen\r\n            if (goingDown && headRow - len > this.rows) {\r\n                this.activeCols[c] = false;\r\n            } else if (!goingDown && headRow + len < 0) {\r\n                this.activeCols[c] = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    private draw() {\r\n        const w = this.canvas.width / this.dpr;\r\n        const h = this.canvas.height / this.dpr;\r\n        const s = Math.max(8, this.opts.cellSize);\r\n\r\n        this.ctx.clearRect(0, 0, w, h);\r\n        this.ctx.fillStyle = this.opts.color;\r\n        this.ctx.textBaseline = 'top';\r\n        this.ctx.font = `${Math.floor(s)}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", monospace`;\r\n\r\n        // draw visible cells\r\n        for (let r = 0; r < this.rows; r++) {\r\n            for (let c = 0; c < this.cols; c++) {\r\n                const i = r * this.cols + c;\r\n                const a = this.alpha[i];\r\n                if (a <= 0) continue;\r\n                this.ctx.globalAlpha = a;\r\n                this.ctx.fillText(this.chars[i], c * s, r * s);\r\n            }\r\n        }\r\n        this.ctx.globalAlpha = 1;\r\n    }\r\n}\r\n\r\n// here's helpers~\r\nfunction rand(min: number, max: number) { return Math.random() * (max - min) + min; }\r\nfunction randChar(): string {\r\n    const n = Math.floor(Math.random() * 62);\r\n    if (n < 10) return String.fromCharCode(48 + n);         // 0-9\r\n    if (n < 36) return String.fromCharCode(65 + (n - 10));   // A-Z\r\n    return String.fromCharCode(97 + (n - 36));               // a-z\r\n}\r\n", "/**\r\n * defineMatrixxCanvas(tag) function that constructs:\r\n * <matrixx-canvas> Web Component\r\n *\r\n * Attributes:\r\n *  - density:      FLOAT   (0 ~ 10, controls how many columns to render)\r\n *  - limit:        boolean (optional; default=true). When false, density can exceed 10.  \r\n *  - direction:    \"up\" | \"down\" (default: \"up\")\r\n *  - bits-color:   string  (CSS color for bits; default: \"#00ff00\")\r\n *  - rain-display: \"riverflow\" | \"waterfall\" (default: \"riverflow\")\r\n *\r\n * This component spawns multiple <bit-rain-column> children with random\r\n * “left”, “duration”, “delay”, “font-size”, and “blur” attributes. \r\n * Passing `rain-display=\"waterfall\"` causes each column to fade-out at the end;\r\n * otherwise, columns use the default “riverflow” (instant reset).\r\n */\r\n\r\nimport './bit-rain-column';\r\nimport { CharamaskEngine, CharamaskOptions } from './charamask-engine';\r\n\r\nexport type BitRainMode = \"waterfall\" | \"riverflow\" | \"charamask\";\r\n\r\nexport function defineMatrixxCanvas(tag = 'matrixx-canvas') {\r\n  if (typeof window === 'undefined' || typeof customElements === 'undefined') return;\r\n  if (customElements.get(tag)) return;\r\n  class MatrixxCanvas extends HTMLElement {\r\n    private shadow: ShadowRoot;\r\n    private chara?: CharamaskEngine;\r\n    static get observedAttributes() {\r\n      return ['density', 'limit', 'direction', 'bits-color', 'rain-display',\r\n        'cell-size', 'speed', 'tail-min', 'tail-max'];\r\n    }\r\n\r\n    constructor() {\r\n      super();\r\n      this.shadow = this.attachShadow({ mode: 'open' });\r\n    }\r\n\r\n    connectedCallback() {\r\n      this.render();\r\n    }\r\n\r\n    attributeChangedCallback() {\r\n      // hot-update when possible\r\n      const mode = (this.getAttribute('rain-display') ?? 'riverflow') as BitRainMode;\r\n      if (mode === 'charamask' && this.chara) {\r\n        this.chara.setOptions(this.readCharamaskOptions());\r\n      } else {\r\n        // for DOM modes, a cheap rebuild is fine\r\n        this.render();\r\n      }\r\n    }\r\n\r\n    private render() {\r\n      const mode = (this.getAttribute('rain-display') ?? 'riverflow') as BitRainMode;\r\n\r\n      /** ==== For charamask theme ============================= */\r\n\r\n      if (mode === 'charamask') {\r\n        // clear existing DOM children (columns) if any\r\n        this.shadow.innerHTML = `\r\n        <style>\r\n          :host {\r\n            position: fixed; inset: 0;\r\n            width: 100vw; height: 100vh;\r\n            overflow: hidden; z-index: 0; pointer-events: none;\r\n          }\r\n          canvas { width: 100%; height: 100%; display:block; }\r\n        </style>\r\n        <canvas part=\"canvas\"></canvas>\r\n      `;\r\n        const canvas = this.shadow.querySelector('canvas') as HTMLCanvasElement;\r\n        // start/update engine\r\n        if (!this.chara) {\r\n          this.chara = new CharamaskEngine(canvas, this.readCharamaskOptions());\r\n          this.chara.start();\r\n          // pause on hidden\r\n          document.addEventListener('visibilitychange', () => {\r\n            if (!this.chara) return;\r\n            if (document.hidden) this.chara.pause(); else this.chara.resume();\r\n          });\r\n        } else {\r\n          this.chara.attach(canvas);\r\n          this.chara.setOptions(this.readCharamaskOptions());\r\n        }\r\n        return;\r\n      }\r\n\r\n      /** ==== For classic columns-based theme ============================= */\r\n\r\n      // ─── 1. Read & normalize attributes ───────────────────────────────────\r\n      const limitAttr = this.getAttribute('limit');\r\n      const directionAttr = this.getAttribute('direction');\r\n      const bitsColor = this.getAttribute('bits-color') ?? '#00ff00';\r\n      const displayAttr = this.getAttribute('rain-display') ?? 'riverflow';\r\n      const densityAttr = this.getAttribute('density') ?? '4';\r\n\r\n      const direction = (directionAttr === 'down') ? 'down' : 'up';\r\n      const rainDisplay = displayAttr as BitRainMode;\r\n      const limit = (limitAttr === null || limitAttr === 'true' || limitAttr === '1');\r\n\r\n      let density = parseFloat(densityAttr.trim());\r\n      if (isNaN(density)) {\r\n        console.warn(`[MatrixxCanvas] invalid density (“${densityAttr}”). Defaulting to 4.`);\r\n        density = 4;\r\n      }\r\n      if (limit && (density < 0 || density > 10)) {\r\n        console.warn(`[MatrixxCanvas] density must be between 0 and 10 when limit=true. Got: ${densityAttr}. Resetting to 4.`);\r\n        density = 4;\r\n      }\r\n\r\n      // ─── 2. Compute how many columns spawn ───────────────────────────\r\n      const count = Math.floor(1 + density * 20);\r\n      if (!limit && count > 320) {\r\n        console.warn(`[MatrixxCanvas] rain-display=\"riverflow\", but ${count} columns may be too many for performance.`);\r\n      }\r\n\r\n      // ─── 3. Build an array of per-column random parameters ─────────────────\r\n      const columns = Array.from({ length: count }, () => ({\r\n        left: `${Math.random() * 100}vw`,\r\n        duration: 5 + Math.random() * 5, // between 5s and 10s\r\n        delay: Math.random() * 10,     // random start offset\r\n        fontSize: 10 + Math.random() * 18, // between 10px and 28px\r\n        blur: Math.random() * 2       // up to 2px blur\r\n      }));\r\n\r\n      // ─── 4. Inject the container style and spawn <bit-rain-column> tags ────\r\n      // Pass `rain-display=\"${rainDisplay}\"` down to each child.\r\n      this.shadow.innerHTML = `\r\n      <style>\r\n        :host {\r\n          position: fixed;\r\n          top: 0;\r\n          left: 0;\r\n          width: 100vw;\r\n          height: 100vh;\r\n          overflow: hidden;\r\n          z-index: 0; \r\n          pointer-events: none;\r\n        }\r\n      </style>\r\n\r\n      ${columns.map(col => `\r\n        <bit-rain-column\r\n          left=\"${col.left}\"\r\n          duration=\"${col.duration}\"\r\n          delay=\"${col.delay}\"\r\n          font-size=\"${col.fontSize}\"\r\n          blur=\"${col.blur}\"\r\n          direction=\"${direction}\"\r\n          bits-color=\"${bitsColor}\"\r\n          rain-display=\"${rainDisplay}\"\r\n        ></bit-rain-column>\r\n      `).join('\\n')}\r\n    `;\r\n    }\r\n\r\n    private readCharamaskOptions(): CharamaskOptions {\r\n      const direction = (this.getAttribute('direction') === 'down') ? 'down' : 'up';\r\n      const color = this.getAttribute('bits-color') ?? '#00ff00';\r\n      const densityAttr = this.getAttribute('density') ?? '4';\r\n      let density = parseFloat(densityAttr);\r\n      if (isNaN(density)) density = 4;\r\n      const limitAttr = this.getAttribute('limit');\r\n      const limit = (limitAttr === null || limitAttr === 'true' || limitAttr === '1');\r\n      if (limit) density = Math.max(0, Math.min(10, density));\r\n\r\n      const cellSize = parseInt(this.getAttribute('cell-size') ?? '18', 10);\r\n      const speed = parseFloat(this.getAttribute('speed') ?? '22'); // cells/sec\r\n      const tailMin = parseInt(this.getAttribute('tail-min') ?? '6', 10);\r\n      const tailMax = parseInt(this.getAttribute('tail-max') ?? '18', 10);\r\n\r\n      return { direction, color, density, cellSize, speed, tailMin, tailMax };\r\n    }\r\n  }\r\n  customElements.define(tag, MatrixxCanvas);\r\n}\r\n", "// src/index.ts\r\n//\r\n// This “entry” point is what users will import in order to\r\n// register *all* of Web Components in one go.\r\n//\r\n\r\nimport { defineBitRainColumn } from './bit-rain-column';\r\nimport { defineMatrixxCanvas } from './matrixx-canvas';\r\n\r\n// Public attribute typings (string | number unions are friendly to HTML)\r\nexport type MatrixxCanvasAttributes = {\r\n    'rain-display'?: 'riverflow' | 'waterfall' | 'charamask';\r\n    direction?: 'up' | 'down';\r\n    density?: number | `${number}`;\r\n    'cell-size'?: number | `${number}`;\r\n    speed?: number | `${number}`;\r\n    'tail-min'?: number | `${number}`;\r\n    'tail-max'?: number | `${number}`;\r\n    'bits-color'?: string;\r\n    limit?: boolean | 'true' | 'false';\r\n};\r\n\r\nexport function defineMatrixx(tag = 'matrixx-canvas') {\r\n    // SSR guard\r\n    if (typeof window === 'undefined' || typeof customElements === 'undefined') return;\r\n\r\n    // Defines\r\n    defineBitRainColumn();\r\n    defineMatrixxCanvas();\r\n}\r\n\r\nexport { };\r\n\r\ndeclare global {\r\n    namespace JSX {\r\n        interface IntrinsicElements {\r\n            'matrixx-canvas': {\r\n                'rain-display'?: 'riverflow' | 'waterfall' | 'charamask';\r\n                direction?: 'up' | 'down';\r\n                density?: number | `${number}`;\r\n                'cell-size'?: number | `${number}`;\r\n                speed?: number | `${number}`;\r\n                'tail-min'?: number | `${number}`;\r\n                'tail-max'?: number | `${number}`;\r\n                'bits-color'?: string;\r\n                limit?: boolean | 'true' | 'false';\r\n                [k: string]: any;\r\n            };\r\n        }\r\n    }\r\n    interface HTMLElementTagNameMap {\r\n        'matrixx-canvas': HTMLElement;\r\n        'bit-rain-column': HTMLElement;\r\n    }\r\n}\r\n", "import { defineMatrixx } from './index';\r\n\r\nif (typeof window !== 'undefined' && typeof customElements !== 'undefined') {\r\n    defineMatrixx();\r\n}\r\n\r\nexport * from './index';     // assure same types/exports\r\nexport {};                   // keep it a module\r\n\r\ndeclare global {\r\n    namespace JSX {\r\n        interface IntrinsicElements {\r\n            'matrixx-canvas': {\r\n                'rain-display'?: 'riverflow' | 'waterfall' | 'charamask';\r\n                direction?: 'up' | 'down';\r\n                density?: number | `${number}`;\r\n                'cell-size'?: number | `${number}`;\r\n                speed?: number | `${number}`;\r\n                'tail-min'?: number | `${number}`;\r\n                'tail-max'?: number | `${number}`;\r\n                'bits-color'?: string;\r\n                limit?: boolean | 'true' | 'false';\r\n                [k: string]: any;\r\n            };\r\n        }\r\n    }\r\n    interface HTMLElementTagNameMap {\r\n        'matrixx-canvas': HTMLElement;\r\n        'bit-rain-column': HTMLElement;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["defineBitRainColumn", "tag", "BitRainColumn", "_a", "_b", "_c", "_d", "_e", "_f", "_g", "_h", "durationAttr", "delayAttr", "fontSizeAttr", "blurAttr", "left", "dirAttr", "bitsColor", "rainDisplay", "duration", "delay", "fontSize", "blur", "direction", "displayMode", "len", "bit", "keyframeName", "styleElem", "idx", "spanList", "CharamaskEngine", "canvas", "options", "hard", "cssW", "cssH", "dpr", "s", "i", "randChar", "ctx", "next", "cellChanged", "dirChanged", "tick", "t", "dt", "goingDown", "c", "rand", "d", "speed", "deltaCells", "headRow", "k", "r", "a", "w", "h", "min", "max", "n", "defineMatrixxCanvas", "MatrixxCanvas", "limitAttr", "directionAttr", "displayAttr", "densityAttr", "limit", "density", "count", "columns", "col", "color", "cellSize", "tailMin", "tailMax", "defineMatrixx", "defineMatrixx"]
}
