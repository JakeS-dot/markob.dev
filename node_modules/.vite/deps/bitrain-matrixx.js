import "./chunk-5WRI5ZAA.js";

// node_modules/bitrain-matrixx/dist/chunk-DHJRUIQA.js
function R(o = "bit-rain-column") {
  if (typeof globalThis == "undefined" || typeof globalThis.HTMLElement == "undefined" || typeof globalThis.customElements == "undefined" || customElements.get(o)) return;
  class i extends HTMLElement {
    constructor() {
      super();
      this.bits = [];
      this.shadow = this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      var m, C, A, $, k, S, z, E;
      let e = (m = this.getAttribute("duration")) != null ? m : "10", n = (C = this.getAttribute("delay")) != null ? C : "0", s = (A = this.getAttribute("font-size")) != null ? A : "14", t = ($ = this.getAttribute("blur")) != null ? $ : "0", h = (k = this.getAttribute("left")) != null ? k : "0px", p = (S = this.getAttribute("direction")) != null ? S : "up", c = (z = this.getAttribute("bits-color")) != null ? z : "#00ff00", u = (E = this.getAttribute("rain-display")) != null ? E : "riverflow", l = Number(e), d = Number(n), b = Number(s), v = Number(t), f = p === "down" ? "down" : "up", w = u, y = Math.floor(Math.random() * 20) + 10;
      this.bits = Array.from({ length: y }, () => Math.random() < 0.5 ? "0" : "1"), this.shadow.innerHTML = `
      <style>
        :host {
          position: absolute;
          ${f === "down" ? "top: 0;" : "bottom: 0;"}
          left: ${h};
          font-size: ${b}px;
          filter: blur(${v}px);
          font-family: monospace;
          line-height: 1.1;
          color: ${c};
          display: flex;
          flex-direction: column;
          /* animation will be injected after layout in RAF */
        }

        /* ─── 4 built-in keyframes ───────────────────────────────────────────*/
        @keyframes move-up {
          0%   { transform: translateY(100%);  opacity: 1; }
          100% { transform: translateY(-calc(100vh + 100%)); opacity: 1; }
        }
        @keyframes move-down {
          0%   { transform: translateY(-100%); opacity: 1; }
          100% { transform: translateY(calc(100vh + 100%));  opacity: 1; }
        }
        @keyframes waterfall-up {
          0%   { transform: translateY(100%);  opacity: 1; }
          80%  { opacity: 1; }
          100% { transform: translateY(-100%); opacity: 0; }
        }
        @keyframes waterfall-down {
          0%   { transform: translateY(-100%); opacity: 1; }
          80%  { opacity: 1; }
          100% { transform: translateY(100%);  opacity: 0; }
        }
      </style>

      ${this.bits.map((M) => `<span class="bit">${M}</span>`).join("")}
    `, requestAnimationFrame(() => {
        let M;
        w === "waterfall" ? M = f === "down" ? "waterfall-down" : "waterfall-up" : M = f === "down" ? "move-down" : "move-up";
        let H = this.shadow.querySelector("style");
        H.textContent += `
        :host {
          animation: ${M} ${l}s linear infinite;
          animation-delay: -${d}s;
        }
      `, this.startUpdatingBits();
      });
    }
    disconnectedCallback() {
      clearInterval(this.intervalId);
    }
    startUpdatingBits() {
      this.intervalId = window.setInterval(() => {
        let e = Math.floor(Math.random() * this.bits.length);
        this.bits[e] = Math.random() < 0.5 ? "0" : "1";
        let n = this.shadow.querySelectorAll(".bit");
        n[e] && (n[e].textContent = this.bits[e]);
      }, 200);
    }
  }
  customElements.define(o, i);
}
var g = class {
  constructor(i, a) {
    this.raf = null;
    this.paused = false;
    this.dpr = 1;
    this.cols = 0;
    this.rows = 0;
    this.heads = [];
    this.tails = [];
    this.activeCols = [];
    this.last = 0;
    this.onWindowResize = () => this.resize(false);
    this.resize = (i2 = false) => {
      let a2 = this.canvas.clientWidth || this.canvas.getBoundingClientRect().width || innerWidth, r = this.canvas.clientHeight || this.canvas.getBoundingClientRect().height || innerHeight, e = Math.max(1, Math.floor(devicePixelRatio || 1));
      if (!i2 && this.canvas.width === Math.floor(a2 * e) && this.canvas.height === Math.floor(r * e) && this.dpr === e) return;
      this.dpr = e, this.canvas.width = Math.max(1, Math.floor(a2 * e)), this.canvas.height = Math.max(1, Math.floor(r * e)), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.scale(e, e);
      let n = Math.max(8, this.opts.cellSize);
      this.cols = Math.max(1, Math.floor(a2 / n)), this.rows = Math.max(1, Math.floor(r / n)), this.chars = new Array(this.cols * this.rows), this.alpha = new Float32Array(this.cols * this.rows), this.active = new Array(this.cols * this.rows).fill(false);
      for (let s = 0; s < this.chars.length; s++) this.chars[s] = T();
      this.seedStreaks();
    };
    this.canvas = i, this.opts = a, this.attach(i);
  }
  attach(i) {
    this.canvas = i;
    let a = this.canvas.getContext("2d");
    if (!a) throw new Error("2d context not available");
    this.ctx = a, this.resize(true);
  }
  setOptions(i) {
    let a = i.cellSize !== this.opts.cellSize, r = i.direction !== this.opts.direction;
    this.opts = { ...this.opts, ...i }, a && this.resize(true), r && this.seedStreaks();
  }
  start() {
    if (this.raf !== null) return;
    this.last = performance.now();
    let i = (a) => {
      if (this.paused) {
        this.last = a, this.raf = requestAnimationFrame(i);
        return;
      }
      let r = Math.min(80, a - this.last) / 1e3;
      this.step(r), this.draw(), this.last = a, this.raf = requestAnimationFrame(i);
    };
    this.raf = requestAnimationFrame(i), addEventListener("resize", this.onWindowResize);
  }
  pause() {
    this.paused = true;
  }
  resume() {
    this.paused = false;
  }
  stop() {
    this.raf !== null && cancelAnimationFrame(this.raf), this.raf = null, removeEventListener("resize", this.onWindowResize);
  }
  seedStreaks() {
    this.heads = new Array(this.cols).fill(0), this.tails = new Array(this.cols).fill(0), this.activeCols = new Array(this.cols).fill(false);
    let i = this.opts.direction === "down";
    for (let a = 0; a < this.cols; a++) this.heads[a] = i ? -x(0, this.rows) : this.rows + x(0, this.rows), this.tails[a] = Math.floor(x(this.opts.tailMin, this.opts.tailMax + 1)), this.activeCols[a] = Math.random() < this.activationProb();
  }
  activationProb() {
    let i = Math.max(0, Math.min(10, this.opts.density));
    return 0.06 + 0.08 * Math.pow(i / 10, 0.9);
  }
  step(i) {
    let { speed: a, direction: r } = this.opts, n = Math.max(1, a) * i;
    for (let t = 0; t < this.alpha.length; t++) !this.active[t] && this.alpha[t] > 0 && (this.alpha[t] = Math.max(0, this.alpha[t] - 1.2 * i), this.alpha[t] === 0 && (this.chars[t] = T())), this.active[t] = false;
    let s = r === "down";
    for (let t = 0; t < this.cols; t++) {
      if (!this.activeCols[t]) if (Math.random() < this.activationProb() * i) this.activeCols[t] = true, this.tails[t] = Math.floor(x(this.opts.tailMin, this.opts.tailMax + 1)), this.heads[t] = s ? -1 : this.rows + 1;
      else continue;
      this.heads[t] += s ? n : -n;
      let h = Math.floor(this.heads[t]), p = this.tails[t];
      for (let c = 0; c < p; c++) {
        let u = s ? h - c : h + c;
        if (u < 0 || u >= this.rows) continue;
        let l = u * this.cols + t, d = c / p, b = 1 - d * d;
        this.alpha[l] = Math.max(this.alpha[l], b), this.active[l] = true;
      }
      s && h - p > this.rows ? this.activeCols[t] = false : !s && h + p < 0 && (this.activeCols[t] = false);
    }
  }
  draw() {
    let i = this.canvas.width / this.dpr, a = this.canvas.height / this.dpr, r = Math.max(8, this.opts.cellSize);
    this.ctx.clearRect(0, 0, i, a), this.ctx.fillStyle = this.opts.color, this.ctx.textBaseline = "top", this.ctx.font = `${Math.floor(r)}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace`;
    for (let e = 0; e < this.rows; e++) for (let n = 0; n < this.cols; n++) {
      let s = e * this.cols + n, t = this.alpha[s];
      t <= 0 || (this.ctx.globalAlpha = t, this.ctx.fillText(this.chars[s], n * r, e * r));
    }
    this.ctx.globalAlpha = 1;
  }
};
function x(o, i) {
  return Math.random() * (i - o) + o;
}
function T() {
  let o = Math.floor(Math.random() * 62);
  return o < 10 ? String.fromCharCode(48 + o) : o < 36 ? String.fromCharCode(65 + (o - 10)) : String.fromCharCode(97 + (o - 36));
}
function L(o = "matrixx-canvas") {
  if (typeof window == "undefined" || typeof customElements == "undefined" || customElements.get(o)) return;
  class i extends HTMLElement {
    static get observedAttributes() {
      return ["density", "limit", "direction", "bits-color", "rain-display", "cell-size", "speed", "tail-min", "tail-max"];
    }
    constructor() {
      super(), this.shadow = this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      this.render();
    }
    attributeChangedCallback() {
      var e;
      ((e = this.getAttribute("rain-display")) != null ? e : "riverflow") === "charamask" && this.chara ? this.chara.setOptions(this.readCharamaskOptions()) : this.render();
    }
    render() {
      var v, f, w, y;
      if (((v = this.getAttribute("rain-display")) != null ? v : "riverflow") === "charamask") {
        this.shadow.innerHTML = `
        <style>
          :host {
            position: fixed; inset: 0;
            width: 100vw; height: 100vh;
            overflow: hidden; z-index: 0; pointer-events: none;
          }
          canvas { width: 100%; height: 100%; display:block; }
        </style>
        <canvas part="canvas"></canvas>
      `;
        let m = this.shadow.querySelector("canvas");
        this.chara ? (this.chara.attach(m), this.chara.setOptions(this.readCharamaskOptions())) : (this.chara = new g(m, this.readCharamaskOptions()), this.chara.start(), document.addEventListener("visibilitychange", () => {
          this.chara && (document.hidden ? this.chara.pause() : this.chara.resume());
        }));
        return;
      }
      let e = this.getAttribute("limit"), n = this.getAttribute("direction"), s = (f = this.getAttribute("bits-color")) != null ? f : "#00ff00", t = (w = this.getAttribute("rain-display")) != null ? w : "riverflow", h = (y = this.getAttribute("density")) != null ? y : "4", p = n === "down" ? "down" : "up", c = t, u = e === null || e === "true" || e === "1", l = parseFloat(h.trim());
      isNaN(l) && (console.warn(`[MatrixxCanvas] invalid density (“${h}”). Defaulting to 4.`), l = 4), u && (l < 0 || l > 10) && (console.warn(`[MatrixxCanvas] density must be between 0 and 10 when limit=true. Got: ${h}. Resetting to 4.`), l = 4);
      let d = Math.floor(1 + l * 20);
      !u && d > 320 && console.warn(`[MatrixxCanvas] rain-display="riverflow", but ${d} columns may be too many for performance.`);
      let b = Array.from({ length: d }, () => ({ left: `${Math.random() * 100}vw`, duration: 5 + Math.random() * 5, delay: Math.random() * 10, fontSize: 10 + Math.random() * 18, blur: Math.random() * 2 }));
      this.shadow.innerHTML = `
      <style>
        :host {
          position: fixed;
          top: 0;
          left: 0;
          width: 100vw;
          height: 100vh;
          overflow: hidden;
          z-index: 0; 
          pointer-events: none;
        }
      </style>

      ${b.map((m) => `
        <bit-rain-column
          left="${m.left}"
          duration="${m.duration}"
          delay="${m.delay}"
          font-size="${m.fontSize}"
          blur="${m.blur}"
          direction="${p}"
          bits-color="${s}"
          rain-display="${c}"
        ></bit-rain-column>
      `).join(`
`)}
    `;
    }
    readCharamaskOptions() {
      var d, b, v, f, w, y;
      let r = this.getAttribute("direction") === "down" ? "down" : "up", e = (d = this.getAttribute("bits-color")) != null ? d : "#00ff00", n = (b = this.getAttribute("density")) != null ? b : "4", s = parseFloat(n);
      isNaN(s) && (s = 4);
      let t = this.getAttribute("limit");
      (t === null || t === "true" || t === "1") && (s = Math.max(0, Math.min(10, s)));
      let p = parseInt((v = this.getAttribute("cell-size")) != null ? v : "18", 10), c = parseFloat((f = this.getAttribute("speed")) != null ? f : "22"), u = parseInt((w = this.getAttribute("tail-min")) != null ? w : "6", 10), l = parseInt((y = this.getAttribute("tail-max")) != null ? y : "18", 10);
      return { direction: r, color: e, density: s, cellSize: p, speed: c, tailMin: u, tailMax: l };
    }
  }
  customElements.define(o, i);
}
function P(o = "matrixx-canvas") {
  typeof window == "undefined" || typeof customElements == "undefined" || (R(), L());
}

// node_modules/bitrain-matrixx/dist/auto.js
typeof window != "undefined" && typeof customElements != "undefined" && P();
export {
  P as defineMatrixx
};
//# sourceMappingURL=bitrain-matrixx.js.map
